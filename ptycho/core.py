from typing import List, Tuple, Union, Optional, Callable
from ptychoep.ptycho.data import DiffractionData
from ptychoep.backend.backend import np


class Ptycho:
    """
    A container class for managing ptychographic reconstruction data.

    This class handles object/probe initialization, scan positions, and
    a collection of DiffractionData objects.
    """

    def __init__(self):
        # Object, probe, scan positions, and diffraction data are set later
        self.obj: Optional[np().ndarray] = None
        self.prb: Optional[np().ndarray] = None
        self.obj_len: Optional[int] = None
        self.prb_len: Optional[int] = None
        self._diff_data: List[DiffractionData] = []

    # --- Object and Probe ---
    def set_object(self, obj: np().ndarray):
        """
        Set the complex object (amplitude-phase image).

        Parameters
        ----------
        obj : ndarray
            Square 2D complex array representing the object.
        """
        if obj.shape[0] != obj.shape[1]:
            raise ValueError("The object must be square-shaped.")
        self.obj = obj
        self.obj_len = obj.shape[0]

    def set_probe(self, probe: np().ndarray):
        """
        Set the probe (illumination function).

        Parameters
        ----------
        probe : ndarray
            Square 2D complex array representing the probe.
        """
        if probe.shape[0] != probe.shape[1]:
            raise ValueError("The probe must be square-shaped.")
        self.prb = probe
        self.prb_len = probe.shape[0]

    # --- DiffractionData management ---
    def add_diffraction_data(self, diff_data: DiffractionData):
        """
        Add a single DiffractionData instance to the internal list.
        """
        if not isinstance(diff_data, DiffractionData):
            raise TypeError("diff_data must be a DiffractionData instance")
        self._diff_data.append(diff_data)

    def add_diffraction_data_list(self, diff_data_list: List[DiffractionData]):
        """
        Add multiple DiffractionData objects to the internal list.
        """
        for d in diff_data_list:
            self.add_diffraction_data(d)

    def clear_diffraction_data(self):
        """
        Clear all currently stored diffraction data.
        """
        self._diff_data.clear()

    def sort_diffraction_data(
        self,
        key: Union[str, Callable[[DiffractionData], float]] = "center_distance",
        center: tuple[int, int] | None = None,
        reverse: bool = False,
    ):
        """
        Sort the internal diffraction data list.

        Parameters
        ----------
        key : str or callable
            Sorting key. Supported values:
            - "center_distance": Distance from object center or specified `center`.
            - "meta:sort_key": Use d.meta["sort_key"] as the sorting value.
            - callable: A function mapping DiffractionData -> float.
        center : tuple of int, optional
            Center position for computing "center_distance".
        reverse : bool
            If True, sort in descending order.
        """
        if callable(key):
            score = key
        elif key == "center_distance":
            if center is None:
                if self.obj_len is None:
                    raise ValueError("Object size unknown. Set object first or specify center manually.")
                center = (self.obj_len // 2, self.obj_len // 2)
            cy, cx = center
            def score(d: DiffractionData):
                y, x = d.position
                return (y - cy) ** 2 + (x - cx) ** 2
        elif key == "meta:sort_key":
            def score(d: DiffractionData):
                return d.meta.get("sort_key", 0.0)
        else:
            raise ValueError(f"Unknown key: {key}")

        self._diff_data.sort(key=score, reverse=reverse)

    def set_diffraction_from_forward(self, diff_list: List[DiffractionData], append: bool = False):
        """
        Register diffraction data generated by forward simulation.

        Parameters
        ----------
        diff_list : list of DiffractionData
            Output from forward simulation.
        append : bool
            If True, append to existing data. Otherwise, overwrite.
        """
        if not append:
            self.clear_diffraction_data()
        self.add_diffraction_data_list(diff_list)

    def forward_and_set_diffraction(self, positions: List[Tuple[int, int]], append: bool = False):
        """
        Perform forward simulation using specified scan positions and register the result.

        Parameters
        ----------
        positions : list of tuple
            List of scan coordinates [(y,x), ...].
        append : bool
            If True, append to existing data. Otherwise, overwrite.
        """
        from .forward import generate_diffraction
        diff_list = generate_diffraction(self, positions)
        self.set_diffraction_from_forward(diff_list, append=append)

    @property
    def scan_pos(self) -> List[Tuple[int, int]]:
        """
        List of scan positions (legacy-compatible).
        """
        return [d.position for d in self._diff_data]

    @property
    def diffs(self) -> List[np().ndarray]:
        """
        List of diffraction patterns (legacy-compatible).
        """
        return [d.diffraction for d in self._diff_data]
